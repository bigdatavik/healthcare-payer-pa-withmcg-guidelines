"""
Prior Authorization Review Page - AI-Powered PA Processing with LangGraph Agent

This page allows reviewers to process PA requests using an intelligent LangGraph agent
that orchestrates multiple AI tools to evaluate clinical evidence against MCG guidelines.

Architecture:
- Config from environment (no hardcoding)
- WorkspaceClient for UC function calls and vector search
- LangGraph ReAct agent with specialized tools
- Complete PA queue workflow with traceability
"""

import streamlit as st
import os
import json
import time
import pandas as pd
from datetime import datetime
from databricks.sdk import WorkspaceClient

st.set_page_config(page_title="PA Review", page_icon="üè•", layout="wide")
st.title("üè• Prior Authorization Review")

st.markdown("""
**Intelligent PA Processing:** Uses LangGraph AI Agent to evaluate clinical evidence against MCG guidelines.
The agent autonomously orchestrates multiple tools to gather evidence, answer MCG questions, and make authorization decisions.
""")

# ============================================
# SECTION 1: CONFIGURATION FROM ENVIRONMENT
# ============================================

# Core configuration (set via app.yaml from config.yaml)
CATALOG = os.getenv("CATALOG_NAME", "healthcare_payer_pa_withmcg_guidelines_dev")
SCHEMA = os.getenv("SCHEMA_NAME", "main")
WAREHOUSE_ID = os.getenv("DATABRICKS_WAREHOUSE_ID", "148ccb90800933a1")
ENVIRONMENT = os.getenv("ENVIRONMENT", "dev")

# Vector Search indexes (fully qualified names)
CLINICAL_INDEX = f"{CATALOG}.{SCHEMA}.patient_clinical_records_index"
GUIDELINES_INDEX = f"{CATALOG}.{SCHEMA}.clinical_guidelines_index"

# LLM endpoint for agent
LLM_ENDPOINT = os.getenv("LLM_ENDPOINT", "databricks-claude-sonnet-4-5")

# Tables
REQUESTS_TABLE = f"{CATALOG}.{SCHEMA}.authorization_requests"
CLINICAL_TABLE = f"{CATALOG}.{SCHEMA}.patient_clinical_records"
AUDIT_TRAIL_TABLE = f"{CATALOG}.{SCHEMA}.pa_audit_trail"

# Decision thresholds (from config.yaml)
AUTO_APPROVE_THRESHOLD = float(os.getenv("AUTO_APPROVE_THRESHOLD", "0.80"))  # 80%+
MANUAL_REVIEW_THRESHOLD = float(os.getenv("MANUAL_REVIEW_THRESHOLD", "0.60"))  # 60-80%

# ============================================
# SECTION 2: DATABRICKS CLIENT
# ============================================

@st.cache_resource
def get_workspace_client():
    """Initialize Databricks WorkspaceClient (automatically authenticated in Databricks Apps)"""
    try:
        return WorkspaceClient()
    except Exception as e:
        st.error(f"‚ùå Failed to initialize Databricks client: {e}")
        return None

w = get_workspace_client()

if not w:
    st.error("""
    **Setup Required:**
    1. Ensure app is deployed to Databricks Apps
    2. Run `databricks bundle deploy --target dev`
    3. Run `./deploy_app_source.sh dev` to deploy app source code
    4. Verify config in `config.yaml`
    """)
    st.stop()

# ============================================
# SECTION 3: HELPER FUNCTIONS
# ============================================

def call_uc_function(function_name, *args, timeout=50, show_debug=False):
    """
    Call a Unity Catalog function using Statement Execution API
    
    Args:
        function_name: Name of the UC function (without catalog.schema prefix)
        *args: Arguments to pass to the function
        timeout: Query timeout in seconds
        show_debug: Whether to show debug info in UI
    
    Returns:
        Function result (parsed JSON if applicable)
    """
    try:
        # Escape single quotes in string arguments for SQL
        escaped_args = []
        for arg in args:
            if isinstance(arg, str):
                # Escape single quotes by doubling them
                escaped_arg = arg.replace("'", "''")
                escaped_args.append(f"'{escaped_arg}'")
            elif isinstance(arg, bool):
                # Convert Python bool to SQL boolean
                escaped_args.append('true' if arg else 'false')
            elif arg is None:
                escaped_args.append('null')
            else:
                escaped_args.append(str(arg))
        
        args_str = ', '.join(escaped_args)
        query = f"SELECT {CATALOG}.{SCHEMA}.{function_name}({args_str}) as result"
        
        if show_debug:
            st.info(f"üîç Executing: {function_name}(...)")
        
        # Execute via Statement Execution API
        result = w.statement_execution.execute_statement(
            warehouse_id=WAREHOUSE_ID,
            statement=query,
            wait_timeout=f"{timeout}s"
        )
        
        if result.status.state.value == "SUCCEEDED":
            if result.result and result.result.data_array:
                data = result.result.data_array[0][0]
                
                # Try to parse as JSON if it's a string
                if isinstance(data, str):
                    try:
                        parsed = json.loads(data)
                        return parsed
                    except:
                        return data
                elif isinstance(data, dict):
                    return data
                elif isinstance(data, (list, tuple)):
                    # Handle STRUCT return types (returned as arrays)
                    # For check_mcg_guidelines which returns STRUCT
                    if function_name == "check_mcg_guidelines" and len(data) >= 5:
                        return {
                            'guideline_id': data[0],
                            'platform': data[1],
                            'title': data[2],
                            'questionnaire': json.loads(data[3]) if isinstance(data[3], str) else data[3],
                            'decision_criteria': data[4],
                            'content': data[5] if len(data) > 5 else None
                        }
                    return data
                else:
                    return data
            return None
        else:
            if show_debug:
                st.error(f"‚ùå Query failed: {result.status.state.value}")
                if result.status.error:
                    st.error(f"Error: {result.status.error.message}")
            return None
    
    except Exception as e:
        if show_debug:
            st.error(f"‚ùå Error calling UC function {function_name}: {e}")
        return None

def load_pending_requests():
    """
    Load all pending PA requests from authorization_requests table
    
    Returns:
        List of dicts with request details
    """
    try:
        query = f"""
        SELECT 
            request_id,
            patient_id,
            procedure_code,
            diagnosis_code,
            urgency,
            created_at
        FROM {REQUESTS_TABLE}
        WHERE decision IS NULL
        ORDER BY 
            CASE 
                WHEN urgency = 'STAT' THEN 1
                WHEN urgency = 'URGENT' THEN 2
                ELSE 3
            END,
            created_at ASC
        """
        
        result = w.statement_execution.execute_statement(
            warehouse_id=WAREHOUSE_ID,
            statement=query,
            wait_timeout="30s"
        )
        
        if result.status.state.value == "SUCCEEDED":
            if result.result and result.result.data_array:
                # Convert to list of dicts
                pending = []
                for row in result.result.data_array:
                    pending.append({
                        'request_id': row[0],
                        'patient_id': row[1],
                        'procedure_code': row[2],
                        'diagnosis_code': row[3],
                        'urgency': row[4],
                        'created_at': row[5]
                    })
                return pending
        return []
    
    except Exception as e:
        st.error(f"‚ùå Error loading pending requests: {e}")
        return []

def load_patient_clinical_notes(patient_id):
    """
    Load all clinical notes for a patient from patient_clinical_records table
    
    Args:
        patient_id: Patient ID
    
    Returns:
        String with all clinical notes concatenated
    """
    try:
        query = f"""
        SELECT content
        FROM {CLINICAL_TABLE}
        WHERE patient_id = '{patient_id}'
        AND chunk_index = 0
        ORDER BY created_at DESC
        LIMIT 10
        """
        
        result = w.statement_execution.execute_statement(
            warehouse_id=WAREHOUSE_ID,
            statement=query,
            wait_timeout="30s"
        )
        
        if result.status.state.value == "SUCCEEDED":
            if result.result and result.result.data_array:
                notes = []
                for row in result.result.data_array:
                    notes.append(row[0])
                return "\n\n---\n\n".join(notes)
        return "No clinical notes found."
    
    except Exception as e:
        st.error(f"‚ùå Error loading clinical notes: {e}")
        return "Error loading clinical notes."

def update_pa_decision(request_id, decision, mcg_code, explanation, confidence_score):
    """
    Update authorization_requests table with final decision
    
    Args:
        request_id: PA request ID
        decision: APPROVED | DENIED | MANUAL_REVIEW
        mcg_code: MCG guideline code
        explanation: Human-readable explanation
        confidence_score: Overall confidence (0.0-1.0)
    """
    try:
        # Escape single quotes in explanation
        explanation_escaped = explanation.replace("'", "''")
        
        query = f"""
        UPDATE {REQUESTS_TABLE}
        SET 
            decision = '{decision}',
            mcg_code = '{mcg_code}',
            explanation = '{explanation_escaped}',
            confidence_score = {confidence_score},
            decision_date = current_timestamp(),
            reviewed_by = 'AI_AGENT'
        WHERE request_id = '{request_id}'
        """
        
        result = w.statement_execution.execute_statement(
            warehouse_id=WAREHOUSE_ID,
            statement=query,
            wait_timeout="30s"
        )
        
        return result.status.state.value == "SUCCEEDED"
    
    except Exception as e:
        st.error(f"‚ùå Error updating PA decision: {e}")
        return False

def save_audit_trail_entry(request_id, question_number, question_text, answer, 
                           evidence, evidence_source, confidence):
    """
    Insert a single Q&A entry into pa_audit_trail table
    
    Args:
        request_id: PA request ID (links to authorization_requests)
        question_number: Question number (1, 2, 3, ...)
        question_text: MCG question text
        answer: YES or NO
        evidence: Clinical evidence used
        evidence_source: Source type (CLINICAL_NOTE, XRAY, etc.)
        confidence: AI confidence for this answer (0.0-1.0)
    """
    try:
        # Escape single quotes
        question_escaped = question_text.replace("'", "''")
        evidence_escaped = evidence.replace("'", "''") if evidence else ''
        
        audit_id = f"{request_id}_Q{question_number}"
        
        query = f"""
        INSERT INTO {AUDIT_TRAIL_TABLE} VALUES (
            '{audit_id}',
            '{request_id}',
            {question_number},
            '{question_escaped}',
            '{answer}',
            '{evidence_escaped}',
            '{evidence_source}',
            {confidence},
            current_timestamp()
        )
        """
        
        result = w.statement_execution.execute_statement(
            warehouse_id=WAREHOUSE_ID,
            statement=query,
            wait_timeout="30s"
        )
        
        return result.status.state.value == "SUCCEEDED"
    
    except Exception as e:
        st.error(f"‚ùå Error saving audit trail entry: {e}")
        return False

# ============================================
# SECTION 4: LANGCHAIN TOOLS FOR AGENT
# ============================================

try:
    from langchain_core.tools import Tool, StructuredTool
    from pydantic import BaseModel, Field
    from langgraph.prebuilt import create_react_agent
    from langchain_core.messages import SystemMessage
    from databricks_langchain import ChatDatabricks
    
    LANGCHAIN_AVAILABLE = True
    
    # Tool input schemas (Pydantic models)
    class CheckMCGInput(BaseModel):
        procedure_code: str = Field(description="CPT procedure code (e.g., '29881')")
        diagnosis_code: str = Field(description="ICD-10 diagnosis code (e.g., 'M23.205')")
    
    class SearchClinicalInput(BaseModel):
        patient_id: str = Field(description="Patient ID to search records for")
        query: str = Field(description="Search query (e.g., MCG question text)")
    
    class AnswerMCGInput(BaseModel):
        clinical_evidence: str = Field(description="Clinical evidence text from vector search")
        question: str = Field(description="MCG question to answer")
    
    # Tool wrapper functions
    def check_mcg_wrapper(procedure_code: str, diagnosis_code: str) -> str:
        """Retrieves MCG guideline and questionnaire for a procedure/diagnosis"""
        result = call_uc_function("check_mcg_guidelines", procedure_code, diagnosis_code, show_debug=False)
        return json.dumps(result, indent=2) if result else json.dumps({"error": "No guideline found"})
    
    def search_clinical_wrapper(patient_id: str, query: str) -> str:
        """Searches patient clinical records using vector search"""
        try:
            if not w:
                return json.dumps({"error": "WorkspaceClient not initialized"})
            
            # Vector search via REST API
            body = {
                "columns": ["patient_id", "record_type", "content"],
                "filters": {"patient_id": patient_id},
                "num_results": 3,
                "query_text": query
            }
            
            response = w.api_client.do(
                'POST',
                f'/api/2.0/vector-search/indexes/{CLINICAL_INDEX}/query',
                body=body
            )
            
            if isinstance(response, dict) and 'error_code' in response:
                error_msg = response.get('message', 'Unknown error')
                return json.dumps({"error": f"Vector Search error: {error_msg}"})
            
            data_array = response.get('result', {}).get('data_array', [])
            
            if data_array:
                formatted = []
                for row in data_array:
                    formatted.append({
                        "patient_id": row[0],
                        "record_type": row[1],
                        "content": row[2]
                    })
                return json.dumps(formatted, indent=2)
            return json.dumps([])
        except Exception as e:
            return json.dumps({"error": f"Search failed: {str(e)}"})
    
    def answer_mcg_wrapper(clinical_evidence: str, question: str) -> str:
        """Answers an MCG question using clinical evidence and LLM"""
        result = call_uc_function("answer_mcg_question", clinical_evidence, question, show_debug=False)
        return json.dumps(result, indent=2) if result else json.dumps({"error": "Answer generation failed"})
    
    # Create LangChain Tools (use StructuredTool for multi-arg functions)
    check_mcg_tool = StructuredTool.from_function(
        func=check_mcg_wrapper,
        name="check_mcg_guidelines",
        description="Retrieves the MCG guideline and questionnaire for a given procedure code and diagnosis code. Use this FIRST to get the list of questions that need to be answered. Returns JSON with guideline_id, platform, title, questionnaire (array of questions), decision_criteria.",
        args_schema=CheckMCGInput
    )
    
    search_clinical_tool = StructuredTool.from_function(
        func=search_clinical_wrapper,
        name="search_clinical_records",
        description="Searches the patient's clinical records using semantic vector search. Use this to find evidence for each MCG question. Pass the patient_id and the question text as the query. Returns JSON array with patient_id, record_type, content.",
        args_schema=SearchClinicalInput
    )
    
    answer_mcg_tool = StructuredTool.from_function(
        func=answer_mcg_wrapper,
        name="answer_mcg_question",
        description="Answers an MCG question (YES/NO) using clinical evidence and AI reasoning. REQUIRES clinical evidence from search_clinical_records first. Pass the evidence text and the question. Returns JSON with answer (YES/NO), reasoning, confidence.",
        args_schema=AnswerMCGInput
    )
    
    # ============================================
    # SECTION 5: LANGGRAPH AGENT
    # ============================================
    
    @st.cache_resource
    def create_pa_agent(_version="v2"):  # Version parameter to force cache refresh
        """Create the LangGraph ReAct agent with all PA tools"""
        try:
            # Initialize LLM (Claude Sonnet 4.5 for excellent function calling)
            llm = ChatDatabricks(
                endpoint=LLM_ENDPOINT,
                temperature=0.1,  # Low temperature for reliable tool calls
                max_tokens=3000
            )
            
            # Create agent with all tools
            tools_list = [check_mcg_tool, search_clinical_tool, answer_mcg_tool]
            
            # CRITICAL: Bind tools to LLM for consistent JSON format
            llm_with_tools = llm.bind_tools(tools_list)
            
            agent = create_react_agent(
                model=llm_with_tools,
                tools=tools_list
            )
            
            return agent
        except Exception as e:
            st.error(f"‚ùå Error creating agent: {e}")
            import traceback
            st.error(traceback.format_exc())
            return None

except ImportError as e:
    LANGCHAIN_AVAILABLE = False
    st.error(f"‚ùå LangChain/LangGraph not available: {e}")
    st.stop()

# ============================================
# SECTION 6: SAMPLE PA REQUESTS FOR TESTING
# ============================================

SAMPLE_REQUESTS = {
    "Knee Arthroscopy (SHOULD APPROVE - 100%)": {
        "patient_id": "PT00001",
        "procedure_code": "29881",
        "diagnosis_code": "M23.205",
        "urgency": "ROUTINE",
        "notes": "58-year-old male with right knee medial meniscus tear. MRI confirms tear. Failed 8 weeks of physical therapy and NSAIDs. Pain limits daily activities. Cleared by cardiologist for surgery."
    },
    "Total Knee Replacement (SHOULD APPROVE - 100%)": {
        "patient_id": "PT00016",
        "procedure_code": "27447",
        "diagnosis_code": "M17.11",
        "urgency": "URGENT",
        "notes": "68-year-old female with severe osteoarthritis right knee. X-ray shows complete loss of joint space. Failed 12 weeks conservative management including PT, injections, NSAIDs. Unable to climb stairs or walk >100 feet. BMI 28."
    },
    "Lumbar Fusion (SHOULD MANUAL REVIEW - 70%)": {
        "patient_id": "PT00025",
        "procedure_code": "22630",
        "diagnosis_code": "M51.36",
        "urgency": "URGENT",
        "notes": "52-year-old with chronic low back pain, L4-L5 disc degeneration. MRI shows moderate stenosis. Tried physical therapy 6 weeks and NSAIDs. Pain impacts work. No red flag symptoms."
    }
}

# ============================================
# SECTION 7: UI - PA REQUEST FORM
# ============================================

st.markdown("---")
st.markdown("### üìã PA Request Input")

# Three-source tabs for PA requests
tab1, tab2, tab3 = st.tabs(["üìä From Queue", "üß™ Sample Cases", "‚úçÔ∏è Custom"])

# Initialize session state for selected request
if 'selected_request' not in st.session_state:
    st.session_state.selected_request = None

# TAB 1: FROM QUEUE (Production workflow)
with tab1:
    st.markdown("**Load pending PA requests from database**")
    
    if st.button("üîÑ Refresh Queue", key="refresh_queue"):
        st.session_state.pending_requests = load_pending_requests()
    
    # Load on first view
    if 'pending_requests' not in st.session_state:
        st.session_state.pending_requests = load_pending_requests()
    
    if st.session_state.pending_requests:
        st.success(f"‚úÖ {len(st.session_state.pending_requests)} pending requests found")
        
        # Display with urgency indicators
        for req in st.session_state.pending_requests:
            urgency_icon = "üî¥" if req['urgency'] == "STAT" else "üü°" if req['urgency'] == "URGENT" else "üü¢"
            label = f"{urgency_icon} {req['request_id']} - {req['patient_id']} - CPT {req['procedure_code']}"
            
            if st.button(label, key=f"queue_{req['request_id']}"):
                # Load full request data
                st.session_state.selected_request = {
                    'source': 'queue',
                    'request_id': req['request_id'],
                    'patient_id': req['patient_id'],
                    'procedure_code': req['procedure_code'],
                    'diagnosis_code': req['diagnosis_code'],
                    'urgency': req['urgency'],
                    'notes': load_patient_clinical_notes(req['patient_id'])
                }
                st.success(f"‚úÖ Loaded {req['request_id']}")
                st.rerun()
    else:
        st.info("‚ÑπÔ∏è No pending PA requests in queue. Try Sample Cases tab to test the system.")

# TAB 2: SAMPLE CASES (Demo/testing)
with tab2:
    st.markdown("**Pre-built test cases with expected outcomes**")
    
    for sample_name, sample_data in SAMPLE_REQUESTS.items():
        if st.button(sample_name, key=f"sample_{sample_name}"):
            st.session_state.selected_request = {
                'source': 'sample',
                'request_id': f"SAMPLE_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                **sample_data
            }
            st.success(f"‚úÖ Loaded sample: {sample_name}")
            st.rerun()

# TAB 3: CUSTOM (Edge case testing)
with tab3:
    st.markdown("**Enter custom PA request details**")
    
    col1, col2 = st.columns(2)
    
    with col1:
        custom_patient_id = st.text_input("Patient ID", value="PT00099", key="custom_patient")
        custom_procedure = st.text_input("Procedure Code (CPT)", value="29881", key="custom_proc")
    
    with col2:
        custom_diagnosis = st.text_input("Diagnosis Code (ICD-10)", value="M23.205", key="custom_diag")
        custom_urgency = st.selectbox("Urgency", ["ROUTINE", "URGENT", "STAT"], key="custom_urgency")
    
    custom_notes = st.text_area(
        "Clinical Notes",
        value="Enter patient clinical notes, history, imaging results, etc.",
        height=150,
        key="custom_notes"
    )
    
    if st.button("üìù Use Custom Request", key="use_custom"):
        st.session_state.selected_request = {
            'source': 'custom',
            'request_id': f"CUSTOM_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            'patient_id': custom_patient_id,
            'procedure_code': custom_procedure,
            'diagnosis_code': custom_diagnosis,
            'urgency': custom_urgency,
            'notes': custom_notes
        }
        st.success("‚úÖ Custom request loaded")
        st.rerun()

# Display selected request
if st.session_state.selected_request:
    st.markdown("---")
    st.markdown("### üìÑ Current PA Request")
    
    req = st.session_state.selected_request
    
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Request ID", req['request_id'])
    col2.metric("Patient ID", req['patient_id'])
    col3.metric("Procedure (CPT)", req['procedure_code'])
    col4.metric("Diagnosis (ICD-10)", req['diagnosis_code'])
    
    with st.expander("üìã Clinical Notes", expanded=False):
        st.text_area("Notes", value=req['notes'], height=200, disabled=True, label_visibility="collapsed")
    
    # ============================================
    # SECTION 8: AGENT EXECUTION
    # ============================================
    
    st.markdown("---")
    
    col1, col2 = st.columns([1, 3])
    with col1:
        analyze_btn = st.button("ü§ñ Review PA Request", type="primary", use_container_width=True)
    with col2:
        st.caption(f"The AI agent will evaluate clinical evidence against MCG guidelines using {LLM_ENDPOINT}")
    
    if analyze_btn:
        st.markdown("---")
        st.markdown("### ü§ñ PA Authorization Workflow")
        
        total_start = time.time()
        
        # STEP 1: Get MCG Questionnaire
        st.markdown("#### üìã Step 1: Retrieve MCG Questionnaire")
        with st.spinner("Fetching MCG guideline..."):
            guideline_result = call_uc_function("check_mcg_guidelines", req['procedure_code'], req['diagnosis_code'], show_debug=False)
            
            if not guideline_result or 'error' in str(guideline_result):
                st.error(f"‚ùå No MCG guideline found for procedure {req['procedure_code']} + diagnosis {req['diagnosis_code']}")
                st.stop()
            
            # Extract guideline info
            mcg_code = guideline_result.get('guideline_id', 'UNKNOWN')
            questionnaire_json = guideline_result.get('questionnaire', '[]')
            
            try:
                questions = json.loads(questionnaire_json)
                st.success(f"‚úÖ Found MCG Guideline: **{mcg_code}** with **{len(questions)} questions**")
                st.json(guideline_result)
            except:
                st.error("‚ùå Failed to parse questionnaire JSON")
                st.stop()
        
        # STEP 2: Loop through EACH question
        st.markdown(f"#### üîç Step 2: Answer All {len(questions)} MCG Questions")
        
        mcg_answers = []
        progress_bar = st.progress(0)
        
        for i, q_obj in enumerate(questions, 1):
            question = q_obj.get('question', str(q_obj))
            
            with st.expander(f"Question {i}/{len(questions)}: {question[:80]}...", expanded=False):
                # 2a. Search for clinical evidence
                st.write("**üîé Searching clinical records...**")
                evidence_result = search_clinical_wrapper(req['patient_id'], question)
                
                try:
                    evidence_data = json.loads(evidence_result)
                    if 'error' in evidence_data:
                        evidence_text = "No clinical evidence found"
                        st.warning(f"‚ö†Ô∏è {evidence_data['error']}")
                    elif isinstance(evidence_data, list) and evidence_data:
                        evidence_parts = [f"[{e['record_type']}] {e['content']}" for e in evidence_data[:3]]
                        evidence_text = "\n".join(evidence_parts)
                        st.write(f"‚úÖ Found {len(evidence_data)} relevant records")
                        st.code(evidence_text, language="text")
                    else:
                        evidence_text = "No clinical evidence found"
                        st.write("‚ÑπÔ∏è No relevant records found")
                except:
                    evidence_text = str(evidence_result)[:500]
                    st.write("‚ÑπÔ∏è Using raw evidence")
                
                # 2b. Answer the question using LLM
                st.write("**üí° Answering MCG question...**")
                answer_result = call_uc_function("answer_mcg_question", evidence_text, question, show_debug=False)
                
                if answer_result:
                    answer_text = str(answer_result)
                    answer_clean = "YES" if "YES" in answer_text.upper() else "NO" if "NO" in answer_text.upper() else "UNCLEAR"
                    
                    if answer_clean == "YES":
                        st.success(f"‚úÖ **Answer: {answer_clean}**")
                    elif answer_clean == "NO":
                        st.error(f"‚ùå **Answer: {answer_clean}**")
                    else:
                        st.warning(f"‚ö†Ô∏è **Answer: {answer_clean}**")
                    
                    st.write(answer_text)
                    
                    mcg_answers.append({
                        "question_num": i,
                        "question": question,
                        "answer": answer_clean,
                        "evidence": evidence_text[:200] + "..." if len(evidence_text) > 200 else evidence_text,
                        "reasoning": answer_text,
                        "confidence": 0.9 if answer_clean in ["YES", "NO"] else 0.5
                    })
                else:
                    st.error("‚ùå Failed to get answer")
                    mcg_answers.append({
                        "question_num": i,
                        "question": question,
                        "answer": "ERROR",
                        "evidence": evidence_text[:200],
                        "reasoning": "UC function failed",
                        "confidence": 0.0
                    })
            
            progress_bar.progress(i / len(questions))
        
        # STEP 3: Calculate Decision
        st.markdown("#### üéØ Step 3: Calculate Authorization Decision")
        
        yes_count = sum(1 for a in mcg_answers if a['answer'] == "YES")
        total_questions = len(questions)
        confidence = yes_count / total_questions if total_questions > 0 else 0.0
        
        if confidence >= AUTO_APPROVE_THRESHOLD:
            decision = "APPROVED"
            decision_color = "green"
            decision_icon = "‚úÖ"
        elif confidence >= MANUAL_REVIEW_THRESHOLD:
            decision = "MANUAL_REVIEW"
            decision_color = "orange"
            decision_icon = "‚ö†Ô∏è"
        else:
            decision = "DENIED"
            decision_color = "red"
            decision_icon = "‚ùå"
        
        elapsed_time = (time.time() - total_start) * 1000
        st.success(f"‚úÖ Analysis complete in {elapsed_time:.0f}ms")
        
        # Store in session state for later sections
        st.session_state['pa_decision'] = decision
        st.session_state['pa_confidence'] = confidence
        st.session_state['pa_mcg_code'] = mcg_code
        st.session_state['pa_mcg_answers'] = mcg_answers
        st.session_state['pa_yes_count'] = yes_count
        st.session_state['pa_total_questions'] = total_questions
            # System prompt defining workflow and decision logic
            system_prompt = f"""You are a Prior Authorization AI Agent for healthcare payers. Your job is to evaluate PA requests against MCG clinical guidelines.

CRITICAL WORKFLOW - FOLLOW EVERY STEP IN ORDER:

STEP 1: Get the MCG Questionnaire
   ‚Üí Call: check_mcg_guidelines("{req['procedure_code']}", "{req['diagnosis_code']}")
   ‚Üí This returns a guideline with a "questionnaire" field containing a JSON array of questions
   ‚Üí Parse the questionnaire JSON to extract ALL questions

STEP 2: Loop Through EVERY Question in the Questionnaire
   ‚Üí For EACH question in the questionnaire array:
      a) Call: search_clinical_records("{req['patient_id']}", "<question_text>")
         This returns clinical evidence relevant to the question
      b) Call: answer_mcg_question("<evidence_text>", "<question_text>")
         This returns YES/NO answer with reasoning
      c) Record the answer for this question
   ‚Üí You MUST process ALL questions in the questionnaire - do not stop early!

STEP 3: Calculate Decision
   ‚Üí Count how many YES answers you got
   ‚Üí Calculate: confidence = YES_count / total_questions
   ‚Üí Apply decision rules:
      ‚Ä¢ If confidence >= {AUTO_APPROVE_THRESHOLD}: decision = "APPROVED"
      ‚Ä¢ If confidence >= {MANUAL_REVIEW_THRESHOLD} and < {AUTO_APPROVE_THRESHOLD}: decision = "MANUAL_REVIEW"
      ‚Ä¢ If confidence < {MANUAL_REVIEW_THRESHOLD}: decision = "DENIED"

STEP 4: Provide Final JSON Response
{{
  "decision": "APPROVED|MANUAL_REVIEW|DENIED",
  "confidence": 0.XX,
  "mcg_code": "<guideline_id>",
  "total_questions": N,
  "yes_answers": M,
  "mcg_answers": [
    {{"question": "...", "answer": "YES/NO", "evidence": "...", "confidence": 0.XX}},
    ...
  ],
  "explanation": "Brief summary of decision"
}}

CRITICAL RULES:
- You MUST call check_mcg_guidelines FIRST to get the questionnaire
- You MUST process EVERY question in the questionnaire (not just 1 or 2)
- You MUST call search_clinical_records before answer_mcg_question for each question
- Do NOT make assumptions or skip questions
- Do NOT stop until you've answered ALL questions

Patient ID: {req['patient_id']}
Procedure Code: {req['procedure_code']}
Diagnosis Code: {req['diagnosis_code']}
"""
            
            # Container for agent reasoning
            reasoning_container = st.container()
            
            with reasoning_container:
                st.markdown("#### üß† Agent Reasoning Process")
                
                # Show agent thinking
                with st.spinner("ü§î Agent is analyzing the PA request..."):
                    try:
                        # Invoke agent with system message
                        result = agent.invoke({
                            "messages": [
                                SystemMessage(content=system_prompt),
                                ("user", f"Evaluate PA request for procedure {req['procedure_code']} (diagnosis {req['diagnosis_code']}) for patient {req['patient_id']}. Follow ALL 4 steps in the workflow. Answer EVERY question in the MCG questionnaire. Provide final JSON output with decision and all Q&A details.")
                            ]
                        })
                        
                        elapsed_time = (time.time() - total_start) * 1000
                        
                        # Parse messages to show reasoning
                        messages = result.get('messages', [])
                        
                        st.success(f"‚úÖ Analysis complete in {elapsed_time:.0f}ms")
                        st.markdown("---")
                        
                        # Show tool calls and reasoning
                        tool_calls = []
                        final_response = ""
                        
                        for msg in messages:
                            # Tool calls (agent action)
                            if hasattr(msg, 'tool_calls') and msg.tool_calls:
                                for tc in msg.tool_calls:
                                    tool_calls.append({
                                        'name': tc['name'],
                                        'args': tc['args']
                                    })
                            
                            # Tool responses
                            if hasattr(msg, 'content') and msg.content:
                                if hasattr(msg, 'name'):  # Tool response
                                    pass  # We'll show these with tool calls
                                else:  # Final agent response
                                    final_response = msg.content
                        
                        # Display tool usage
                        if tool_calls:
                            with st.expander("üîß Tools Used by Agent", expanded=True):
                                for i, tc in enumerate(tool_calls, 1):
                                    st.markdown(f"**{i}. {tc['name']}**")
                                    st.json(tc['args'])
                        
                        # ============================================
                        # SECTION 9: RESULTS DISPLAY WITH TRACEABILITY
                        # ============================================
                        
                        st.markdown("---")
                        st.markdown("### üìä PA Decision")
                        
                        # Parse final response (try to extract JSON)
                        try:
                            # Try to find JSON in final response
                            import re
                            json_match = re.search(r'\{[\s\S]*\}', final_response)
                            if json_match:
                                parsed_response = json.loads(json_match.group())
                            else:
                                # Fallback: try to extract from messages
                                parsed_response = {
                                    'decision': 'MANUAL_REVIEW',
                                    'confidence': 0.5,
                                    'mcg_code': 'UNKNOWN',
                                    'mcg_answers': [],
                                    'explanation': final_response[:500]
                                }
                        except:
                            parsed_response = {
                                'decision': 'MANUAL_REVIEW',
                                'confidence': 0.5,
                                'mcg_code': 'UNKNOWN',
                                'mcg_answers': [],
                                'explanation': final_response[:500]
                            }
                        
                        # Store in session state for saving later
                        st.session_state.agent_result = parsed_response
                        
                        # Display decision badge
                        decision = parsed_response.get('decision', 'MANUAL_REVIEW')
                        confidence = parsed_response.get('confidence', 0.0)
                        mcg_code = parsed_response.get('mcg_code', 'UNKNOWN')
                        
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            if decision == "APPROVED":
                                st.success(f"### ‚úÖ {decision}")
                            elif decision == "DENIED":
                                st.error(f"### ‚ùå {decision}")
                            else:
                                st.warning(f"### ‚ö†Ô∏è {decision}")
                        
                        with col2:
                            st.metric("Confidence", f"{confidence*100:.0f}%")
                        
                        with col3:
                            st.metric("MCG Code", mcg_code)
                        
                        # Traceability Table
                        st.markdown("#### üìã MCG Question Traceability")
                        
                        mcg_answers = parsed_response.get('mcg_answers', [])
                        
                        if mcg_answers:
                            # Convert to DataFrame for display
                            trace_data = []
                            for i, qa in enumerate(mcg_answers, 1):
                                trace_data.append({
                                    'Q#': i,
                                    'Question': qa.get('question', 'N/A'),
                                    'Answer': qa.get('answer', 'N/A'),
                                    'Evidence': qa.get('evidence', 'N/A')[:200] + '...' if len(qa.get('evidence', '')) > 200 else qa.get('evidence', 'N/A'),
                                    'Confidence': f"{qa.get('confidence', 0)*100:.0f}%"
                                })
                            
                            trace_df = pd.DataFrame(trace_data)
                            st.dataframe(trace_df, use_container_width=True, height=300)
                            
                            # Download audit trail
                            csv = trace_df.to_csv(index=False)
                            st.download_button(
                                label="üì• Download Audit Trail (CSV)",
                                data=csv,
                                file_name=f"pa_audit_{req['request_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                mime="text/csv"
                            )
                        else:
                            st.info("‚ÑπÔ∏è No detailed Q&A traceability available. Agent may not have completed all steps.")
                        
                        # Explanation
                        st.markdown("#### üí¨ Decision Explanation")
                        explanation = parsed_response.get('explanation', 'No explanation provided.')
                        st.info(explanation)
                        
                        # ============================================
                        # SECTION 10: SAVE DECISION TO DATABASE
                        # ============================================
                        
                        st.markdown("---")
                        
                        # Only allow saving for queue requests (not samples or custom)
                        if req['source'] == 'queue':
                            st.markdown("### üíæ Save Decision")
                            
                            col1, col2 = st.columns([1, 3])
                            
                            with col1:
                                save_btn = st.button("üíæ Save to Database", type="primary", use_container_width=True)
                            
                            with col2:
                                st.caption("This will update the authorization_requests table and create audit trail entries.")
                            
                            if save_btn:
                                with st.spinner("üíæ Saving decision..."):
                                    # Save main decision
                                    success = update_pa_decision(
                                        req['request_id'],
                                        decision,
                                        mcg_code,
                                        explanation,
                                        confidence
                                    )
                                    
                                    if success:
                                        # Save each Q&A to audit trail
                                        for i, qa in enumerate(mcg_answers, 1):
                                            save_audit_trail_entry(
                                                req['request_id'],
                                                i,
                                                qa.get('question', ''),
                                                qa.get('answer', ''),
                                                qa.get('evidence', ''),
                                                'CLINICAL_RECORD',  # Default source
                                                qa.get('confidence', 0.0)
                                            )
                                        
                                        st.success(f"‚úÖ Decision saved successfully for {req['request_id']}!")
                                        st.balloons()
                                        
                                        # Clear selected request and refresh queue
                                        st.session_state.selected_request = None
                                        st.session_state.pending_requests = load_pending_requests()
                                        
                                        time.sleep(2)
                                        st.rerun()
                                    else:
                                        st.error("‚ùå Failed to save decision. Check logs for details.")
                        else:
                            st.info(f"‚ÑπÔ∏è This is a {req['source']} request. Only queue requests can be saved to the database.")
                    
                    except Exception as e:
                        st.error(f"‚ùå Error during agent execution: {e}")
                        import traceback
                        st.error(traceback.format_exc())

else:
    st.info("üëÜ Select a PA request from one of the tabs above to begin analysis.")

# Footer
st.markdown("---")
st.caption(f"üîß Environment: {ENVIRONMENT} | Catalog: {CATALOG} | LLM: {LLM_ENDPOINT}")
